# Understand Ethereum Transaction Structure

1. 키와 주소

이더리움: 주소, 개인키, 디지털 서명 등을 통해 이더를 소유하고 통제, 키와 주소는 지갑 또는 월렛이라고 부르는 에소프트웨어에 의해 생성되고 관리.

두 유형의 계정
- 외부 소유 계정(EOA - Externally Owned Accounts): 지갑에서 개인키로 생성한 계정
- 컨트랙트 계정 (CA - Contract Accounts): 컨트랙트에서 생성된 계정

개인키: 이더를 지출하는 트랜잭션을 디지털 서명

공개키: 이더를 수신하는 주소로 사용, 타원 곡선 암호화 (ECC)를 사용해 공개키 암호화, secp256k1 표준 타원 곡선 사용.

계정 주소와 디지털 서명 만이 블록체인에서 전송되고 저장됨.

EOA -> EOA: 이더 전송

EOA -> CA: 스마트 컨트랙트 실행

주소생성
- 공개 키의 keccak-256 해시 생성, 256비트의 숫자 제공
- 앞 96비트 (즉 12바이트) 를 버린다. 160비트 (20바이트)의 바이너리 데이터를 가지고 있다.
- 주소를 16진수 문자열로 인코딩한다. 최종적으로 40개 문자의 바이트 스트링을 가지고, 이것이 계정 주소이다.

2. Account: UTXO 의 비효율성 해결, 스마트 컨트랙트 코드를 포함.
- nonce: 해당 account 로부터 보내진 트랜잭션의 수, 0으로 시작, 트랜잭션을 오직 한 번만 실행되게 할 때 사용하는 카운터
- balance: 이더 잔고
- root: 해당 account 가 저장 될 머클 매트리시아 트리의 루트노드
- codehash: 스마트 컨트랜트 바이트 코드의 해시

지갑 (Wallet) 에는 키 값만 소유, 이더나 토큰에 대한 정보는 모두 블록체인 위 기록.

3. Message, Transaction

Transaction: EOA 의 개인키로 서명된 메시지 패키지, ECDSA(Ellictic Curve Digital Signature Algorithm) 이용해 서명
- AccountNonce: 발신자가 보낸 트랜잭션의 개수, 0으로 시작.
- Price: 수수료로 지급할 Gas 가격 (Wei)
- GasLimit: 최대 Gas 사용 범위
- Recipient: 수신처의 주소
- Amount: 전송할 이더의 양 (Wei)
- Payload: 옵션 필드, 스마트 컨트랙트 호출 시 필요한 매개변수 저장, Lack of state 해결
- V, R, S: 서명에 필요한 값들.

Message (내부 트랜잭션): CA 가 다른 CA 에서 보내는 트랜잭션, CA 가 보내기 때문에 서명이 되어 있지 않음.

상태변환: account 의 상태 변화로 표현

채굴과정
- 브로드캐스팅된 트랜잭션 중 아직 채굴되지 않은 트랜잭션 목록을 수집하고 유효하지 않은 트랜잭션을 필터링해야한다.
- 트랜잭션이 유효하기 위해서는 개인키로 적절하게 서명되어 있어야 하고, 계정에 트랜잭션을 수행하기 위한 충분한 잔액이 있어야 한다.
- 논스를 찾는 과정 - ethash 해싱 알고리즘 사용해 가능성 숫자 대입

현재 블록의 난이도 = 이전 블록의 난이도 + 이전 블록의 난이도//2048 * max(1-현재 블록 타임스탬프-이전 블록 타임스탬프)//10,-99) + int(2 ** ((현재 블록 번호 // 100000) - 2))

(//는 integer division)

4. EVM (Ethereum Virtual Machine): 코드가 플랫폼에 상관없이 작동하게 함.

5. Block

비트코인 - 이전 블록헤더 해시, 타임스탬프, 트랜잭션 머클트리 루트, 논스

이더리움 - (비트코인과의 차이점) 트랜잭션 리스트, 가장 최근 상태의 복사본, 블록 넘버, 난이도

Account 상태 저장 
- 머클 패트리시아 트리
- 블록에 연결된 트리: 트랜잭션 머클 트리 루트, 리시트 (트랜잭션 수행 결과) 머클 트리 루트, 상태 머클 패트리시아 트리 루트
- account balance, contract data 효율적으로 관리하기 위함.
- 변경된 부분만 새로 저장하고 나머지는 이전 데이터 주소로 연결.

6. 블록 검증 알고리즘

블록 생성 시 수행하는 트랜잭션 자체에 대한 검증

트랜잭션 전체 수행 시 소모된 총 gas 가 블록의 gasLimit 를 초과하는지 검증

이전 블록 마지막 상태에서 시작해 모든 트랜잭션 수행 후 상태가 현재 블록에 기록된 상태인지 확인.

7. Gas

Price: Gas 당 트랜잭션 요청자가 지급할 금액

Gas Limit: 트랜잭션 수행에 소비될 총 가스 예상량

8. ERC 20 / ERC 721

ERC: Ethereum Request for comment

ERC 20: 디앱 개발자들이 통화적인 가치를 주면서 새 토큰을 적용할 수 있께 함. 대신 토큰의 스마트 컨트랙트를 통해 토큰을 보내려고 하면 토큰 손실로 이어질 수 있음.
- ICO 에서 많이 사용, 서로 다른 기능을 하는 DApp 간 상호운용성 제공

ERC 223: 토큰들이 스마트컨트랙트에서 한번에 다른 지갑으로 보내질 수 있도록 지원. 토큰 손실을 막음.

ERC 777: 모든 사람들에게 스마트 컨트랙트 주소를 볼 수 있게 하고, 기능을 체크할 수 있게함. 트랜잭션이란 요구된 액션 검증에 사용

ERC 721: NFT(Non-Fungible Token), 공유될 수 없는 토큰

ERC-20 특성
- Total Supply (총 발행량)
- Transfer (송금)
- Balance of (잔액)
- Transfer From (유저간 송금)
- Approve (승인)
- Allowance (허용)

결제 수단으로 쓰면 토큰이 파괴되는 현상

9. 스테일 블록 (Uncle block)

비슷한 시간에 다음 블록을 채굴할 경우, 두 블록 모두 유효하지만, 최종적으로 높은 난ㄴ이도를 가진 블록체인이 네트워크에서 허용됨.

버려지는 유효한 블록 = 스테일 블록

네트워크 내에서 생성된 총 스테일 블록의 수는 새로운 블록을 생성하기 위한 평균 시간에 반비례

스테일 블록의 문제점
- 트랜잭션의 확인을 지연.
- 보안에 영향, 블록체인 네트워크의 보안은 네트워크 내 채굴자의 전체 연산 능력으로 측정됨. 연산 능력 향상 시 난이도 올라감, 난이도가 높아질 수록 블록체인은 안전한 블록체인이 되고, 스태일 블록이 생길 수록 불필요한 해시파워가 사용되기 때문에 평균 블록 시간보다 오래 걸리는 생성 시간 때문에 난이도가 낮아져 보안을 떨어뜨린다고 볼 수 있다.

고스트 프로토콜: 스테일 블록을 메인 블록체인에 붙여서 전체 난이도를 상승시키는 방법으로 보안 문제 해결, 모든 블록은 0개 이상의 스테일 블록을 지정할 수 있고, 채굴자는 스테일 블록을 포함하거나 스테일 블록을 채굴한다면 보상을 받는다.

스테일 블록 내에 포함된 트랜잭션 수수료는 받지 않고, 확인을 계산하는 데 사용되지도 않는다.

스테일 블록 채굴자 보상 공식: (uncle_block_number + 8 - block_number) * (현재 보상 리워드) / 8, 나머지 보상은 orphan block (고아 블록)을 포함한 nephew block (조카 블록) 에게 간다.

고스트는 조카가 참조할 수 있는 최대 스케일 블록의 수를 제한해, 채굴자가 단순히 스테일 블록만 채굴하고 블록체인을 멈추지 않게 함.

10. 포크

일반 포크: 둘 이상의 채굴자가 블록을 거의 동시에 채굴했을 경우에 발생하는 임시적 충돌, 둘 중 하나가 더 높은 난이도 가지고 있으면 해결

소프트 포크: 소스코드 변경 후 충돌 해결 위해 해시 파워의 50% 이상 채굴자의 업그레이드 필요한 경우 소프트 포크

하드포크: 모든 채굴자가 업그레이드 해야할 경우 하드 포크

 