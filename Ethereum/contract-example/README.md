# Solidity, Smart Contrat

1. EVM
- 계정
외부 계정: 공개키, 비밀키 쌍으로 동작, 공개키에 의해 정해짐
컨트랙트 계정: 생성되는 시점에 정해짐. (생성한 사용자의 주소, 주소로부터 보내진 트랜잭션의 수 - '논스' 로부터 기반)
모든 계정은 256비트의 문자열들이 서로 키-값으로 영구히 매핑된 스토리지 가지고 있음.

- 트랜잭션
대상 계정이 코드 포함하고 있으면 코드는 실행되고 페이로드(바이너리 데아터)는 입력 데이터로 제공 
대상 계정이 설정되지 않은 경우 트랜잭션은 새 컨트랙트 생성, 논스의 의해 주소 결정.

각 트랜잭션 생성 데이터 페이로드는 EVM 바이트 코드로 실행되기 위해 사용.
컨트랙트를 만들기 위해 실제 코드를 보내는 대신, 실행될 때의 코드를 리턴하는 코드를 보내야 함.
* 컨트랙트가 생성되는 동안, 컨트랙트의 코드는 비어있음. 이 때문에 생성자가 실행을 끝낼ㄷ 때까지 트랜잭션 다시 호출하면 안됨.

- 가스
가스 가격 * 가스 양 지불

- 스토리지, 메모리, 스택
스토리지: 데이터 영역: 함수호출과 트랜잭션 사이에서 영구적 존재
메모리: 메시지 콜에 대해 초기화된 인스턴스, 메모리는 선형이며 바이트 레벨로 다뤄짐. 변경되지 않은 메모리 워드 영역에 액세스 시 
메모리는 256 비트 워드 영역으로 확장, 가스 비용 지불
스택: 모든 연산이 스택이라는 영역에서 처

- 메시지 콜
컨트랙트가 다른 컨트랙트 호출하거나 컨트랙트 아닌 계정으로 Ether 송금할 수 있음.
송신자, 수신자, 데이터 페이로드, Ether, 가스와 리턴 값을 가지고 있어 트랜잭션과 유사

- 델리게이트 콜 / 콜코드와 라이브러리
델리게이트 콜: 대상 주소의 코드가 호출하는 컨트랙트의 컨텍스트 내에서 실행, msg.sender / msg.value 값이 변하지 않는다는 것 외에는 메시지 콜과 동일
컨트랙트가 실행 중 다양한 주소의 코드를 동적으로 불러옴.

- 로그
블록 레벨까지의 모든 절차를 매핑, 특별히 인덱싱된 데이터 구조 데이터를 저장하는 것도 가능.
이벤트를 구현하기 위해 사용.
일부 로그 데이터는 bloom filters 안에 저장, 효율적, 암호화, 안전함.

- 생성
페이로드 데이터가 실행, 결과가 코드로 저장, 호출자와 생성자가 스택의 새 컨트랙트 주소를 받는 다는 점이 일반 메시지 콜과 다름.

- 비활성화와 자기소멸
selfdestruct 연산, 주소에 저장된 남은 ether는 지정된 타켓으로 옮겨지고 스토리와 코드는 해당 상태에서 지워짐.
비활성화: 내부상태 disable

2. Solidity
- Keyword
natspec: 3개의 슬래시, 유저가 트랜잭션에 대한 확인을 요청 받을 때 보여짐.
payable: 이더를 지급하는 것이 가능하도록 함
modifier: 함수 입력값을 입증하는 편리한 방법
internal: 이 컨트랙스 안에서 이것 스스로만 호출 될 수 있다는 의미.
